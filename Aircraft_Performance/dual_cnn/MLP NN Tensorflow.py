# -*- coding: utf-8 -*-
"""Data Preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z45jqc_PvlNKhV-BnspV0hf3dARSIQXD
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 2.x

# organizing data by airfoil name

import pandas as pd
import csv

data = pd.read_csv('General_import14.csv', encoding = "ISO-8859-1")

dict_of_lists = {}

for column_name in data.columns:
    temp_list = data[column_name].tolist()
    dict_of_lists[column_name] = temp_list

print(dict_of_lists)

def getList(dict): 
    return dict.keys()

aircraft_list = getList(dict_of_lists)

# goal here is to create a dictionary with angles and corresponding coefficients for each airfoil while getting rid of empty or NaN values

data_per_airfoil = {}

data_per_airfoil.fromkeys(dict_of_lists.keys(),[])

for name in aircraft_list:
  check = 0
  data_list = []

  while('  ') in dict_of_lists[name]: 
    dict_of_lists[name].remove('  ') 

    dict_of_lists2 = dict_of_lists

  for index in range(0,len(dict_of_lists[name])):
    try:
      float(dict_of_lists2[name][index])
      if check == 0:
        index0 = index + 1
        for index2 in range(index0,len(dict_of_lists[name])):
          try:
            float(dict_of_lists2[name][index2])
            continue
          except:
            data_list_append = dict_of_lists[name][index2]
            data_list.append(data_list_append)
      
        data_per_airfoil[name] = data_list
        check = check+1
    except:
      pass

# Let's create a dictionary with only the geometry

only_geometry = {}

only_geometry.fromkeys(dict_of_lists.keys(),[])


for name in aircraft_list:
  data_list2 = []
  check = 0
  for index in range(0,len(dict_of_lists[name])):
    try:
      float(dict_of_lists2[name][index])
      if check == 0:
        for newindex in range(0,index):
          data_list2_append = dict_of_lists[name][newindex]
          data_list2.append(data_list2_append)
        only_geometry[name] = data_list2
        check = check+1
    except:
      pass

print(data_per_airfoil)

keep_for_later = data_per_airfoil

print(only_geometry)

# let's create a new dictionary with angles added to keywords and corresponding geometries + coefficients in a list

keyword_list = list(data_per_airfoil)

number_aoa = {}

number_aoa.fromkeys(dict_of_lists.keys(),[])

for name in keyword_list:
  number_aoa[name] = len(data_per_airfoil[name]) 


# list_angle is a list of the airfoil names with all the angles associated



keyword_list = list(data_per_airfoil)
list_angle = []

check = 0

for name in keyword_list:
  for index in range(0,len(data_per_airfoil[name])):
    k = data_per_airfoil[name][index].split()
    angle_string = k[0]
    list_angle.append(name+' '+angle_string)
    check = check+1

# Let's take a look at the coordinates only_geometry and preprocess the data

coor_per_airfoil = {}

coor_per_airfoil.fromkeys(dict_of_lists.keys(),[])

for name in aircraft_list:

  xcoor = []
  ycoor = []

  for index in range(0,len(only_geometry[name])):

    
      k = only_geometry[name][index].split()

      x_coor = float(k[0])
      xcoor.append(x_coor)
      

      y_coor = float(k[1])
      ycoor.append(y_coor)
   
  
  coor_per_airfoil[name] = []
  coor_per_airfoil[name].append(xcoor)
  coor_per_airfoil[name].append(ycoor)

# Let's separate xlower from xupper

x_upper = {}
x_upper.fromkeys(dict_of_lists.keys(),[])

for type2 in aircraft_list:
  x_upper_list = []
  for lol in range(0,int(len(coor_per_airfoil[type2][0])/2)):
    
    x_upper_list.append(coor_per_airfoil[type2][0][lol])

  x_upper[type2]= []
  x_upper[type2].append(x_upper_list)
  
   

# print(x_upper)


x_lower = {}
x_lower.fromkeys(dict_of_lists.keys(),[])

for type3 in aircraft_list:
  x_lower_list = []
  for lol2 in range(int(len(coor_per_airfoil[type3][0])/2),int(len(coor_per_airfoil[type3][0]))):
    x_lower_list.append(coor_per_airfoil[type3][0][lol2])

  x_lower[type3]= []
  x_lower[type3].append(x_lower_list)

# print(x_lower)


# Now, separating y_upper from y_lower

y_upper = {}
y_upper.fromkeys(dict_of_lists.keys(),[])

for type2 in aircraft_list:
  y_upper_list = []
  for lol in range(0,int(len(coor_per_airfoil[type2][1])/2)):
    
    y_upper_list.append(coor_per_airfoil[type2][1][lol])

  y_upper[type2]= []
  y_upper[type2].append(y_upper_list)
  
   

# print(y_upper)


y_lower = {}
y_lower.fromkeys(dict_of_lists.keys(),[])

for type3 in aircraft_list:
  y_lower_list = []
  for lol2 in range(int(len(coor_per_airfoil[type3][1])/2),int(len(coor_per_airfoil[type3][1]))):
    y_lower_list.append(coor_per_airfoil[type3][1][lol2])

  y_lower[type3]= []
  y_lower[type3].append(y_lower_list)
  


# print(y_lower)

import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate

x_final_array = list(np.linspace(0, 1, num=50)) # we want 50 terms on the x-axis, and hence a 2x50 array for y-axis 
# (upper and lower surfaces for corresponding x value)

# upper surface interpolation

y_final_upper = {}
y_final_upper.fromkeys(dict_of_lists.keys(),[])

for type4 in aircraft_list:
  try:
  
    f = interpolate.interp1d(x_upper[type4][0], y_upper[type4][0],'cubic') # cubic interpolation used to get more y coordinates
    y_final_upper[type4]= []
    y_final_upper[type4].append(f(x_final_array))

  except:
    print('Error due to '+ type4)

# lower surface interpolation

y_final_lower = {}
y_lower.fromkeys(dict_of_lists.keys(),[])

for type4 in aircraft_list:
  try:
    f = interpolate.interp1d(x_lower[type4][0], y_lower[type4][0],'cubic') # cubic interpolation used to get more y coordinates
    y_final_lower[type4]= []
    y_final_lower[type4].append(f(x_final_array))
  except:
    print('error is because of '+type4)

# Let's merge all y coordinates together

y_final_merged = {}
y_final_merged.fromkeys(dict_of_lists.keys(),[])

for type4 in aircraft_list: 
  y_final_merged[type4] = np.concatenate((y_final_upper[type4][0], y_final_lower[type4][0]), axis=None)

# print(y_final_merged)

# Let's mean center the data
from sklearn import preprocessing

y_final_merged_centered = {}
y_final_merged_centered.fromkeys(dict_of_lists.keys(),[])

for type4 in aircraft_list: 
  y_final_merged_centered[type4] = preprocessing.scale(y_final_merged[type4])

# print(y_final_merged_centered)

# Let's split Angle of Cl and Cd and transform to float numbers in keep_for_later

keep_for_final = {}
keep_for_final.fromkeys(dict_of_lists.keys(),[])
listtest = []


for name in keyword_list:
  listtest2 = []
  for index in range(0,len(keep_for_later[name])):
    k = keep_for_later[name][index].split()
    x = float(k[0])
    y = float(k[1])
    z = float(k[2])
    listtest = [x,y,z]
    listtest2.append(listtest)
  keep_for_final[name] = listtest2


# keep_for_final

final_dict = {}
final_dict2 = {}

check = 0

# Let's create our final dictionary with geometry and lift/drag/angle values with corresponding airfoils

for name in keyword_list:
  for index in range(0,len(keep_for_final[name])):
    keyword = list_angle[check]
    array = np.array(keep_for_final[name][index])
    final_dict[keyword] = y_final_merged_centered[name]
    final_dict2[keyword]=np.append(final_dict[keyword],array)
    check = check+1

# print(final_dict2)

# Let's create a Panda dataframe 

final_dict = final_dict2

aircraft_list_angle = getList(final_dict)

df = pd.DataFrame()

for number in aircraft_list_angle: 
  
  df[number] = pd.Series(final_dict[number])

df_final1 = df.transpose()

df_final1.rename(columns={100: "Angle of Attack", 101: "Lift Coefficient", 102:"Drag Coefficient"},inplace = True)

# df_final1.head()

import tensorflow as tf

# split the data between training and testing datasets: change numbers depending on number of data

train_dataframe = df_final1.sample(frac = 0.8,random_state=0)
test_dataframe = df_final1.drop(train_dataframe.index)

# Let's create our dataset and split input values (geometric values/angles) from target values (lift/drag coefficients)

# train:

target_coefs_train = train_dataframe[['Lift Coefficient','Drag Coefficient']].copy()
del train_dataframe['Lift Coefficient']
del train_dataframe['Drag Coefficient']

dataset_train = tf.data.Dataset.from_tensor_slices((train_dataframe.values, target_coefs_train.values))

# test:

target_coefs_test = test_dataframe[['Lift Coefficient','Drag Coefficient']].copy()
del test_dataframe['Lift Coefficient']
del test_dataframe['Drag Coefficient']
dataset_test = tf.data.Dataset.from_tensor_slices((test_dataframe.values, target_coefs_test.values))


# Let's take a look at our training dataset

# for feat, targ in dataset_test.take(5):
#  print ('Geometry & AOA (at the last index): {}, Target_Lift: {}'.format(feat, targ))

# Let's now actually create the model

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import datasets, layers, models

def build_model():
  model = tf.keras.Sequential([
    tf.keras.layers.Dense(32, activation='relu', input_shape=(101,)),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(2)
    ])

  opt = tf.keras.optimizers.Adam(0.001)
  model.compile(optimizer=opt,
                loss='mse',metrics=['mae', 'mse'])
  return model

# Let's build the model
model = build_model()
# model.summary()

# Let's create our training batch

dataset_train = dataset_train.shuffle(100).batch(1) # shuffling training dataset
dataset_train

# Let's look at the stats for each input feature (not so relevant here since we have literally more than 100)

train_stats = train_dataframe.describe()
# train_stats

dataset_test = dataset_test.batch(1)
dataset_test

# Let's fit this model with our training batch

history = model.fit(dataset_train, validation_data = dataset_test, epochs=25)

plt.plot(history.history['loss'], label = 'loss')
plt.plot(history.history['val_loss'], label = 'val_loss')
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')

hist = pd.DataFrame(history.history)
hist['epoch'] = history.epoch
hist.tail()

predictions = model.predict(dataset_test)

# Let's verify
print(predictions[0],predictions[1],predictions[2])
for feat, targ in dataset_test.take(3):
  print ('Geometry & AOA: {}, Target_Coefs: {}'.format(feat, targ))

print("train score: ", model.evaluate(dataset_train))

print("test score: ", model.evaluate(dataset_test))

